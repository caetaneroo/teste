# core/rate_limiter.py
import asyncio
import time
import logging

logger = logging.getLogger(__name__)

class AdaptiveRateLimiter:
    """
    Rate limiter simples e eficiente para controle de tokens por minuto com coordenaÃ§Ã£o global.
    Removeu lÃ³gica de calibraÃ§Ã£o, mantendo apenas o controle real de rate limit.
    """

    def __init__(self, max_tokens_per_minute: int = 180000, calibration_enabled: bool = False):
        self.max_tpm = max_tokens_per_minute
        self.tokens_used_this_minute = 0
        self.minute_start = time.time()
        self._lock = asyncio.Lock()

        # Controle global de rate limit
        self._global_rate_limit_active = False
        self._global_wait_until = 0.0
        self._rate_limit_lock = asyncio.Lock()
        self._rate_limit_logged = False
        self._current_batch_id = None

        # EstatÃ­sticas essenciais
        self._rate_limit_events = 0
        self.api_rate_limits_detected = 0
        self.prevented_rate_limits = 0
        self.total_waits = 0
        self.total_wait_time = 0.0

        logger.info(
            "AdaptiveRateLimiter inicializado",
            extra={
                'max_tpm': max_tokens_per_minute,
                'action': 'rate_limiter_init'
            }
        )

    def start_batch(self, batch_id: str) -> None:
        """Inicia um novo batch - reset de controles de rate limit"""
        self._current_batch_id = batch_id
        self._rate_limit_logged = False
        self._rate_limit_events = 0
        self.api_rate_limits_detected = 0

        logger.debug(
            f"Rate limiter preparado para batch {batch_id}",
            extra={
                'batch_id': batch_id,
                'action': 'batch_rate_limit_start'
            }
        )

    async def wait_for_tokens(self, estimated_tokens: int) -> int:
        """
        Aguarda tokens disponÃ­veis com controle global coordenado.
        """
        async with self._rate_limit_lock:
            current_time = time.time()
            if self._global_rate_limit_active and current_time < self._global_wait_until:
                remaining_wait = self._global_wait_until - current_time
                if not self._rate_limit_logged:
                    logger.warning(
                        f"ğŸš¨ Rate limit detectado! Iniciando pausa global de {remaining_wait:.1f}s",
                        extra={
                            'batch_id': self._current_batch_id,
                            'global_wait_time': round(remaining_wait, 1),
                            'wait_until_timestamp': self._global_wait_until,
                            'api_rate_limits_detected': self.api_rate_limits_detected,
                            'action': 'rate_limit_event_and_pause_start'
                        }
                    )
                    self._rate_limit_logged = True
                await asyncio.sleep(remaining_wait)
                self._global_rate_limit_active = False
                logger.info(
                    "âœ… Pausa de rate limit finalizada - processamento normal retomado",
                    extra={
                        'batch_id': self._current_batch_id,
                        'action': 'rate_limit_pause_end_and_resolved'
                    }
                )

        # Controle simples de tokens por minuto
        async with self._lock:
            current_time = time.time()
            if current_time - self.minute_start >= 60:
                self.tokens_used_this_minute = 0
                self.minute_start = current_time
            if self.tokens_used_this_minute + estimated_tokens > self.max_tpm:
                wait_time = 60 - (current_time - self.minute_start)
                if wait_time > 0:
                    logger.debug(
                        f"Rate limiting proativo - aguardando {wait_time:.1f}s",
                        extra={
                            'wait_time': wait_time,
                            'max_tpm': self.max_tpm,
                            'action': 'proactive_rate_limit'
                        }
                    )
                    await asyncio.sleep(wait_time)
                    self.tokens_used_this_minute = 0
                    self.minute_start = time.time()
        return estimated_tokens

    async def _activate_global_rate_limit(self, wait_time: float, source: str = 'api'):
        """Ativa rate limit global para todas as requests"""
        async with self._rate_limit_lock:
            current_time = time.time()
            new_wait_until = current_time + wait_time
            if new_wait_until > self._global_wait_until:
                self._global_rate_limit_active = True
                self._global_wait_until = new_wait_until
                self._rate_limit_logged = False
                self.total_waits += 1
                self.total_wait_time += wait_time
                self.prevented_rate_limits += 1
                logger.debug(
                    f"Rate limit global ativado - fonte: {source}",
                    extra={
                        'batch_id': self._current_batch_id,
                        'wait_time': round(wait_time, 1),
                        'source': source,
                        'action': 'global_rate_limit_activated'
                    }
                )

    def record_api_rate_limit_with_context(self, wait_time: float, completed: int, total: int, successful: int, failed: int):
        """
        Registra rate limit da API com contexto e logs apropriados.
        """
        self._rate_limit_events += 1
        remaining = total - successful
        logger.info(
            f"ğŸ“Š Status no rate limit: {successful}/{total} processados | "
            f"âœ…{successful} âŒ{failed} | "
            f"ğŸ”„{remaining} restantes",
            extra={
                'batch_id': self._current_batch_id,
                'completed': successful,
                'total': total,
                'successful_so_far': successful,
                'failed_so_far': failed,
                'remaining': remaining,
                'action': 'rate_limit_status_info'
            }
        )
        logger.warning(
            f"ğŸš¨ Rate limit evento #{self._rate_limit_events} detectado! Aguardando coordenaÃ§Ã£o global...",
            extra={
                'batch_id': self._current_batch_id,
                'rate_limit_event_number': self._rate_limit_events,
                'completed_at_rate_limit': completed,
                'wait_time': wait_time,
                'action': 'rate_limit_event_warning'
            }
        )
        self.api_rate_limits_detected += 1
        asyncio.create_task(self._activate_global_rate_limit(wait_time, 'api_detected'))

    def record_successful_request(self):
        """Reseta flag de evento de rate limit (nÃ£o precisa log extra)"""
        pass

    def record_tokens(self, tokens_used: int) -> None:
        """Registra tokens utilizados no contador atual"""
        self.tokens_used_this_minute += tokens_used
        if self.tokens_used_this_minute > self.max_tpm * 0.9:
            logger.warning(
                "Alta utilizaÃ§Ã£o de tokens detectada",
                extra={
                    'tokens_used': self.tokens_used_this_minute,
                    'max_tpm': self.max_tpm,
                    'utilization_percent': round((self.tokens_used_this_minute / self.max_tpm) * 100, 1),
                    'action': 'high_utilization'
                }
            )

    def get_status(self) -> dict:
        """Retorna status atual do rate limiter"""
        current_time = time.time()
        time_in_minute = current_time - self.minute_start
        tokens_remaining = max(0, self.max_tpm - self.tokens_used_this_minute)
        utilization = (self.tokens_used_this_minute / self.max_tpm) * 100
        return {
            'tokens_used': self.tokens_used_this_minute,
            'tokens_limit': self.max_tpm,
            'tokens_remaining': tokens_remaining,
            'utilization_percent': round(utilization, 2),
            'time_in_minute': round(time_in_minute, 2),
            'total_waits': self.total_waits,
            'total_wait_time': round(self.total_wait_time, 2),
            'prevented_rate_limits': self.prevented_rate_limits,
            'api_rate_limits_detected': self.api_rate_limits_detected,
            'rate_limit_events': self._rate_limit_events,
            'global_rate_limit_active': self._global_rate_limit_active,
            'current_batch_id': self._current_batch_id
        }
