async def _make_api_call(
    self,
    messages: List[Dict[str, str]],
    json_schema: Optional[Dict[str, Any]] = None,
    request_id: str = None
) -> Dict[str, Any]:
    """
    Faz chamada à API com AsyncIaraGenAI e lógica assíncrona corrigida
    """
    
    if not request_id:
        request_id = self._generate_request_id()
    
    # Validar entrada
    if not messages or not isinstance(messages, list):
        return {
            'content': None,
            'tokens_used': 0,
            'success': False,
            'error': 'Messages inválidas',
            'error_type': 'ValidationError',
            'request_id': request_id
        }
    
    # ✅ PREPARAR PARÂMETROS ANTES DO ASYNC
    api_params = {
        "model": self.model,
        "messages": messages,
        "temperature": self.temperature
    }
    
    if self.max_tokens is not None:
        api_params["max_tokens"] = self.max_tokens
    
    if json_schema and isinstance(json_schema, dict):
        api_params["response_format"] = self._prepare_json_schema(json_schema)
    
    # Validar parâmetros
    validation = self._validate_api_params(api_params)
    if not validation['valid']:
        return {
            'content': None,
            'tokens_used': 0,
            'success': False,
            'error': f"Parâmetros inválidos: {', '.join(validation['errors'])}",
            'error_type': 'ValidationError',
            'request_id': request_id
        }
    
    # Estimar tokens necessários
    base_estimate = self.estimate_tokens(messages)
    
    # ✅ RATE LIMITING FORA DO SEMÁFORO
    calibrated_estimate = await self.rate_limiter.wait_for_tokens(base_estimate)
    
    # ✅ CONTROLE DE CONCORRÊNCIA SIMPLIFICADO
    concurrent_started = False
    
    try:
        # Registrar início de requisição concorrente
        self.stats_manager.record_concurrent_start()
        concurrent_started = True
        
        # ✅ RETRY LOGIC FORA DO SEMÁFORO
        last_error = None
        
        for attempt_num in range(1, MAX_RETRY + 1):
            try:
                # ✅ SEMÁFORO APENAS PARA A CHAMADA DA API
                async with self.semaphore:
                    # Rate limiting adicional para tentativas > 1
                    if attempt_num > 1:
                        await self.rate_limiter.wait_for_tokens(base_estimate)
                        await asyncio.sleep(0.1)  # Pequeno delay entre tentativas
                    
                    start_time = time.time()
                    
                    # Log da tentativa
                    logger.debug(
                        f"Tentativa {attempt_num}/{MAX_RETRY} - Chamada à API",
                        extra={
                            'request_id': request_id,
                            'attempt_number': attempt_num,
                            'base_estimate': base_estimate,
                            'calibrated_estimate': calibrated_estimate,
                            'action': 'api_call_attempt'
                        }
                    )
                    
                    # ✅ CHAMADA À API ISOLADA
                    try:
                        response = await self.client.chat.completions.create(**api_params)
                    except Exception as api_error:
                        end_time = time.time()
                        api_response_time = end_time - start_time
                        
                        # Contexto detalhado do erro
                        error_context = self._get_detailed_error_context(api_error, api_params, request_id)
                        
                        # Criar resultado de erro
                        error_result = {
                            'content': None,
                            'tokens_used': 0,
                            'success': False,
                            'error': str(api_error),
                            'error_type': type(api_error).__name__,
                            'error_line': error_context['error_line'],
                            'error_file': error_context['error_file'],
                            'error_function': error_context['error_function'],
                            'api_response_time': api_response_time,
                            'attempts': attempt_num,
                            'request_id': request_id,
                            'full_traceback': error_context['full_traceback']
                        }
                        
                        # ✅ VERIFICAR SE É RATE LIMIT
                        if is_rate_limit_error(error_result):
                            logger.debug(
                                f"Rate limit detectado - tentativa {attempt_num}",
                                extra={
                                    'request_id': request_id,
                                    'attempt_number': attempt_num,
                                    'action': 'rate_limit_detected'
                                }
                            )
                            
                            # Se não é a última tentativa, continua o loop
                            if attempt_num < MAX_RETRY:
                                last_error = error_result
                                continue
                            else:
                                # Última tentativa, retorna erro
                                return error_result
                        else:
                            # Erro não é rate limit, retorna imediatamente
                            return error_result
                    
                    end_time = time.time()
                    api_response_time = end_time - start_time
                
                # ✅ PROCESSAMENTO DA RESPOSTA FORA DO SEMÁFORO
                try:
                    # Validação robusta da resposta
                    if not response:
                        raise ValueError("API retornou resposta None/vazia")
                    
                    # Verificar choices
                    if hasattr(response, 'choices'):
                        choices = response.choices
                    elif isinstance(response, dict) and 'choices' in response:
                        choices = response['choices']
                    else:
                        raise ValueError(f"API retornou resposta sem 'choices'. Tipo: {type(response)}")
                    
                    if not choices or len(choices) == 0:
                        raise ValueError("API retornou choices vazio")
                    
                    # Extrair content
                    first_choice = choices[0]
                    if hasattr(first_choice, 'message'):
                        message = first_choice.message
                    elif isinstance(first_choice, dict) and 'message' in first_choice:
                        message = first_choice['message']
                    else:
                        raise ValueError(f"Choice[0] não tem 'message'. Tipo: {type(first_choice)}")
                    
                    if hasattr(message, 'content'):
                        content = message.content
                    elif isinstance(message, dict) and 'content' in message:
                        content = message['content']
                    else:
                        raise ValueError(f"Message não tem 'content'. Tipo: {type(message)}")
                    
                    # Extrair usage
                    tokens_used = 0
                    input_tokens = 0
                    output_tokens = 0
                    
                    try:
                        if hasattr(response, 'usage') and response.usage:
                            usage = response.usage
                            tokens_used = getattr(usage, 'total_tokens', 0)
                            input_tokens = getattr(usage, 'prompt_tokens', 0)
                            output_tokens = getattr(usage, 'completion_tokens', 0)
                        elif isinstance(response, dict) and 'usage' in response:
                            usage = response['usage']
                            tokens_used = usage.get('total_tokens', 0)
                            input_tokens = usage.get('prompt_tokens', 0)
                            output_tokens = usage.get('completion_tokens', 0)
                    except Exception as usage_error:
                        logger.warning(
                            f"Erro ao extrair usage: {usage_error}",
                            extra={'request_id': request_id, 'action': 'usage_extraction_error'}
                        )
                    
                    # Registrar tokens no rate limiter
                    if tokens_used > 0:
                        self.rate_limiter.record_tokens(tokens_used)
                        self.rate_limiter.record_token_usage(base_estimate, tokens_used)
                    
                    # Calcular custo
                    cost = self.calculate_cost(input_tokens, output_tokens)
                    
                    # Processar JSON se necessário
                    parsed_content = content
                    if json_schema and isinstance(json_schema, dict) and content:
                        try:
                            parsed_content = json.loads(content)
                        except json.JSONDecodeError:
                            parsed_content = content
                    
                    # Log de sucesso
                    logger.debug(
                        "Chamada à API bem-sucedida",
                        extra={
                            'request_id': request_id,
                            'attempt_number': attempt_num,
                            'tokens_used': tokens_used,
                            'api_response_time': round(api_response_time, 3),
                            'action': 'api_call_success'
                        }
                    )
                    
                    # ✅ RETORNO DE SUCESSO
                    return {
                        'content': parsed_content,
                        'raw_content': content,
                        'tokens_used': tokens_used,
                        'input_tokens': input_tokens,
                        'output_tokens': output_tokens,
                        'cached_tokens': 0,
                        'cost': cost,
                        'api_response_time': api_response_time,
                        'success': True,
                        'is_json': json_schema is not None,
                        'attempts': attempt_num,
                        'request_id': request_id
                    }
                    
                except Exception as processing_error:
                    # Erro no processamento da resposta
                    error_context = self._get_detailed_error_context(processing_error, api_params, request_id)
                    
                    logger.error(
                        f"Erro no processamento da resposta - {error_context['error_file']}:{error_context['error_line']}: {processing_error}",
                        extra={
                            'request_id': request_id,
                            'error_context': error_context,
                            'response_type': str(type(response)),
                            'action': 'response_processing_error'
                        }
                    )
                    
                    return {
                        'content': None,
                        'tokens_used': 0,
                        'success': False,
                        'error': str(processing_error),
                        'error_type': type(processing_error).__name__,
                        'error_line': error_context['error_line'],
                        'error_file': error_context['error_file'],
                        'error_function': error_context['error_function'],
                        'api_response_time': api_response_time,
                        'attempts': attempt_num,
                        'request_id': request_id,
                        'full_traceback': error_context['full_traceback']
                    }
                
            except Exception as attempt_error:
                # Erro na tentativa
                last_error = {
                    'content': None,
                    'tokens_used': 0,
                    'success': False,
                    'error': str(attempt_error),
                    'error_type': type(attempt_error).__name__,
                    'attempts': attempt_num,
                    'request_id': request_id
                }
                
                # Se não é rate limit ou é a última tentativa, retorna erro
                if not is_rate_limit_error(last_error) or attempt_num >= MAX_RETRY:
                    return last_error
                
                # Continua para próxima tentativa
                continue
        
        # Se chegou aqui, todas as tentativas falharam
        if last_error:
            return last_error
        else:
            return {
                'content': None,
                'tokens_used': 0,
                'success': False,
                'error': 'Máximo de tentativas excedido',
                'error_type': 'RetryError',
                'attempts': MAX_RETRY,
                'request_id': request_id
            }
            
    except Exception as e:
        # Erro inesperado
        error_context = self._get_detailed_error_context(e, api_params, request_id)
        
        logger.error(
            f"Erro inesperado - {error_context['error_file']}:{error_context['error_line']}: {e}",
            extra={
                'request_id': request_id,
                'error_context': error_context,
                'action': 'unexpected_error'
            }
        )
        
        return {
            'content': None,
            'tokens_used': 0,
            'success': False,
            'error': str(e),
            'error_type': type(e).__name__,
            'error_line': error_context['error_line'],
            'error_file': error_context['error_file'],
            'error_function': error_context['error_function'],
            'request_id': request_id,
            'full_traceback': error_context['full_traceback']
        }
        
    finally:
        # ✅ CLEANUP GARANTIDO
        if concurrent_started:
            self.stats_manager.record_concurrent_end()
