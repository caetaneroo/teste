for coro in asyncio.as_completed(tasks):
    try:
        result = await coro
        results.append(result)
        completed += 1
        
        # âœ… NOVO: Detectar rate limit sem log individual
        current_rate_limits = sum(1 for r in results 
                                if not r.get('success', False) and 
                                any(indicator in r.get('error', '').lower() 
                                    for indicator in ['429', 'rate limit', 'azure-openai error']))
        
        # âœ… VERIFICAR se houve NOVO evento de rate limit
        if current_rate_limits > getattr(self, '_last_rate_limit_count', 0):
            # Calcular estatÃ­sticas no momento do rate limit
            successful_so_far = sum(1 for r in results if r.get('success', False))
            failed_so_far = completed - successful_so_far
            remaining = len(texts) - completed
            
            # âœ… LOG DE INFO: Status quando atingiu rate limit
            logger.info(
                f"ğŸ“Š Status no rate limit: {completed}/{len(texts)} processados | "
                f"âœ…{successful_so_far} âŒ{failed_so_far} | "
                f"ğŸ”„{remaining} restantes",
                extra={
                    'batch_id': batch_id,
                    'completed': completed,
                    'total': len(texts),
                    'successful_so_far': successful_so_far,
                    'failed_so_far': failed_so_far,
                    'remaining': remaining,
                    'action': 'rate_limit_status_info'
                }
            )
            
            # âœ… LOG DE WARNING: Evento de rate limit
            logger.warning(
                f"ğŸš¨ Rate limit evento #{current_rate_limits} detectado! "
                f"Aguardando coordenaÃ§Ã£o global...",
                extra={
                    'batch_id': batch_id,
                    'rate_limit_event_number': current_rate_limits,
                    'completed_at_rate_limit': completed,
                    'action': 'rate_limit_event_warning'
                }
            )
            
            # Atualizar contador
            self._last_rate_limit_count = current_rate_limits
        
        # Log de progresso regular (a cada 5) - SEM rate limits
        if completed in progress_intervals and current_rate_limits == getattr(self, '_last_rate_limit_count', 0):
            elapsed = time.time() - start_time
            rate = completed / elapsed if elapsed > 0 else 0
            eta = (len(texts) - completed) / rate if rate > 0 else 0
            
            successful_so_far = sum(1 for r in results if r.get('success', False))
            failed_so_far = completed - successful_so_far
            recent_successes = successful_so_far - self._last_logged_successes
            self._last_logged_successes = successful_so_far
            
            logger.info(
                f"ğŸ“Š Progresso: {completed}/{len(texts)} ({completed/len(texts)*100:.1f}%) | "
                f"âœ…{successful_so_far} âŒ{failed_so_far} | "
                f"ğŸ†•{recent_successes} novos",
                extra={
                    'batch_id': batch_id,
                    'completed': completed,
                    'total': len(texts),
                    'action': 'batch_progress_regular'
                }
            )
